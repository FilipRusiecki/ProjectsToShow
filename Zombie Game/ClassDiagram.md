[ClassDiagram](http://www.plantuml.com/plantuml/umla/rHbTRziuyZdw5Rm-1CgU-v7aRe5DkiKwJj8DjawCs4sBAug2aSOMBvHea9JTrkX_FmufqQJYECq1zt012elpCPmPpiUG_KDfAdLTyYJZL2dobfQmIdRm9zqxJdOMWkL4rjLweK3Nyo5KTGVq3XR0KrPfeh_GKjIL_fSeRnaeJpQN8WEb1e9pffYeLDf5dIsWqW6udkTKGwgcHqSJLi9Q8QXoa6kwh83iRiIokthU0Q8XLukGLitfiXgOtUkItd9GaHc3WagQQP3ZEnROB8qvkS5Liy0hscXq0de9K5qZtacw5O8x-Yz88CdlP4gvWkFaHvACEFrcGC-VMpydpa5--O5oZWj7bRoLBFUujS81nH3oEwOH4A2Javfpi50Kc7YJ1hNIecJVgMQY2gJqor8C9DKG2mhaEC90NOSA0DUGYLfcyAVWkJ4m6OFMh9efWnfILc6u91ULqhBES7T50iGM3Jr9--7z4M_emIw8qMuJnFXZO-S6CYtamPJCXM8ekqTSd2vPhejsKG2R5NhFC2OxvXZpRoyKw37x3f6CjENo37ZgddxKx92sMqNOSyQv2NyXhKZxTNGqf3EeD8q8hoIRiQhTYxma1psl8QxsZd-WcYZ5U4ARmEGmBkWS24emaYApELNwhqeiAtUGHiS7AToH8aMOHUkK_S1quQIaxeViwYzp-xMtXUMiWl9RweGZntVxvJboIPUfCmOJ-mEhSh7SjGU4NuQED7yslPYwgdMSMkPlOC--ZRnL8vfLJAUFRLJwZUB2uzTSqDoaXeRA2aliZcv3buHcE_UHJWqjXfFAA8SUKJe_Eb9Q6fqCSCeuND8IUjwWw1YCAuNgyYWi9YPou9t8ziWHyQphN4tzTi4MZRIkXDKFNtHTmTnmZcYUisvpRZx5kJ_hqntCGWKSp6uvbbzplAyQy0nqMv3TMRiyTsLejJaFBEvaGpOiW8kCQOIxivfByM-3P8Pr3f1x1uKQUtCPvKp1Ed-DUzrMTjMBpzFXN1NfaJOoEljvyLCc8UtmpmJbvjIehLeTd6tTew3EMAMCSNUsDubQ3x0DWpGegEgIP2v3DDRwbKbJMjw2XBn7Ih4miTQp6kG4xNT4JdlxlN9yHqUEpT65UU3RY3aF_Cxm-_yZ6vIcccMs3RZ99HWFDYRBBWcIPUq2puO-y8kVTiBJhKy8YlG6x_L8AotrWWqqyOqljL8DdJDdt8fBksunlOXDIVetNJ3r_4tcRPd0LrrBU879Uov5QPcVzQydBv-HlvDWKojYnsgVYLgJrw_9Cv1II9ltQ4qmiw2KPuR4aaELy-CViGA1kYVrT0goeu04PSS1zP8g1Thyr3aJBuUCCqtbDt8ZM0PaHBCxfsTaxN-dAucLlQSdjd6dQtfFUzlhkwuTpoNJW6oDazDxRd-4Run144yhJSYvy7Y4VHG7oJ5voAmRmUiIqiF3PWnPCAbhoidFzVAOFawiCA_YgZqBzFDpDiqqMu1f55hMq71OBSFuRk3EJj8nF1uUmX7rVz7ZWgtY0NPbovW45S2GeQs9pVdleXlwMfiuRY0F4Gt50XuXkSZv9f8WJ2sP6zeiz04ougQv0BADx4G2rOL9AelQlcz87IhWVUk8jk122nE_rxceTACEVeOrtCNXAd6_wTxAnMCVwuajElOhjP7lQ4vDIDXMGURnsWG1HfksZMNO__ZkukPiR89rlnrhibfAgFGx4yFAmJTEGVi6x4QTfY5_Edpr-NZJrBEJjLFtYVZQ9eagXC2Hs8_BpQ30PDQmaHoqaNDDSrQhbYsZrL04oHNRqXyEhqPdryF-MqDmQ1HFeZw90q3q5X0bqFkBHmg4prSNgUuptLeJ_0QQti4fBMbuLI-0ylMALgpqMUgpraRA6gRSoDaOiQ2yXX3dz-tqx0gM1jMHtDXxms29iipFff7o2RUXwD7aefhNEkr2qMULteox5BAa74_t7kgSIV1CeGq_ev04J90qM4yPvpOMklkSWWPRPrtGkVGCwwFBtbKIZOPkkBsTAdmDag4FqxXsed8jH3tPiTxYU1nhBy_hSTK5HnxRqYFt4zEp3u84ZUIiHye_WN9ybS3t7uJEp6_xHf41vwxgN9XptnJHRenPMBLV6wOtv5O2pNLXJbRf58M6CdVRUyJ0IBvOmt9G3MXxrFj9TLjoRjQh_3AdkcZB3Lvqhe5c1UHXeVA7RWSwT-mXcEKSxaEd3EVbWP5hZhNo1cWn7_cxrpeaPs1DJKE78nA1ln1qkGl62yLGLjD7smQ2dwqHKrOnPInmBTgeuAldfWkO0YgpeizdGZ9Tb6Pu5voBfRs9KI_1tyRQTk4MlxVtiOuKFnhnQ39oLn0gWUBJKWJOZrO7qUhGjvx6Mk-_UDnoI6UsXOJOZOtVb-jQLXFXOlh1ZBjNfQoZdiY4yyvMOdl_cysa3JDyVGXXG_gr0H_--ihxICt1nkl-YuD_JXrvStJdafPWxz-d9WITjA25zYUJ_k2l_kN5i3yv6u_EpavHyiQcJkAc7auEMCBjHav-Y79dqKKsXMBSgFsF1ZnzHDdXrVlBoUJiu-JzjPjWVjs0ToO5LByPec3eRC8W63lZoToXtM8ZPpZuRgO8fjw7NdrMDg7MMfzVzuVEfj-wB4xcfP67SjjYrgMIjCf5-LPGxYdYJePbPUMgoIwXkfaeM9N3LumwH7V-AyM2mdg9Bzc_lB6rYOjRod6jrZo5M5xYq_2jgAMoiloGotByQOgPhMKe_DF-gy_uxwdFeX8K-CSwLpV3VlHeTk7-Qb9GFIv4pVCJ656bS5R-j7_mERmU-PV_LT3X7do8GnDtdtX5Gu86vPlUZ9Om53dOczeVXhik-Ny0)

@startuml
class Game{
	Game();
	void run();
	void setupMenu();
	void setupLevel(int t_amountZombies);
	void processCollisions();
	void processEvents();
	void update(sf::Time);
	void render();
	void checkPickup();
	void checkGameOver();
	void spawnConsumables();
	void setCharacterSkin();
	void roundChange();
	void timeBetweenRounds();
	bool round_timer = false;
}

Player -- Game
Zombie -- Game
Wall -- Player
Grid -- Game
Consumable -- Player
Medkit -- Consumable 
Bullet -- Wall
CharacterCustomization -- Player
AmmoCrate -- Consumable
Bullet -- Player
Zombie -- Bullet
Zombie -- RecourceHolder 
Settings-- MainMenu
Instructions -- MainMenu
CharacterCustomization -- MainMenu
MainMenu -- Game
RecourceHolder -- Game
class Wall{
	Wall(sf::Vector2f position, int t_width, int t_height){
	
		body.setSize(sf::Vector2f(t_width,t_height));
		body.setPosition(position);
		body.setFillColor(sf::Color::Magenta);
		body.setOrigin(t_width / 2, t_height / 2);}
	
	sf::RectangleShape body;
	sf::Vector2f lastKnownPlayerPos;
	sf::Vector2f lastKnownZombiePos;
	void checkCollisionsWithPlayer(Player &t_player);
	void checkCollisionsWithEnemy(Zombie &t_zombie);
	void draw(sf::RenderWindow& t_window);
        bool isOuter = false;
}



Class Settings{
	void init();
	void draw(sf::RenderWindow& m_window);
	void update();
	void loadContent();


}


Class Medkit{
	Medkit(float t_scale, std::string t_fileName,
        sf::Vector2f t_pos, std::string t_soundFileLoc) : 
        Consumable(t_scale, t_fileName, t_pos, t_soundFileLoc){};
	void pickup(Player &t_player);

}

Class CharacterCustomization{
	void init();
	void draw(sf::RenderWindow&);
	void update();
	void loadContent();
	int selectedSkin = 0;
	int getSkin();

}



class Bullet{
	sf::RectangleShape bulletBody;
	sf::Vector2f velocity;
	float projectileSpeed{};
	void update();
	void initialise(sf::Color t_bulletColor, sf::Vector2f t_bulletSize, float t_projectileSpeed);
	void fire(sf::Vector2f t_goalLocation,sf::Vector2f t_startPosition);
	sf::Clock timeoutCounter;
	enum class State { chambered, moving, fired };
	State bulletState{ State::chambered };

}


Class AmmoCrate{
	Ammocrate(float t_scale, std::string t_fileName,
        sf::Vector2f t_pos, std::string t_soundFileLoc) : 
        Consumable(t_scale, t_fileName, t_pos, t_soundFileLoc){};
	static int amountConsumables;
	void pickup(Player& t_player);
}


Class Consumable{
	Consumable(float t_scale, std::string t_fileName,
 sf::Vector2f t_pos, std::string t_soundFileLoc) :
 scale(t_scale), fileName(t_fileName),
 position(t_pos), pickupSoundFile(t_soundFileLoc){
		if (!this->consumableTexture.loadFromFile("ART/" + t_fileName)){
			std::cout << "error loading Consumable File" <<std::endl;}
		if (!this->pickupSoundBuffer.loadFromFile("resources/assets/audio/Military Voice Pack/" + t_soundFileLoc)){
			std::cout << "error loading Consumable File" << std::endl;}
		this->pickupSound.setBuffer(pickupSoundBuffer);
		this->consumableSprite.setTexture(consumableTexture);
		this->consumableSprite.setScale(sf::Vector2f(scale, scale));
		this->consumableSprite.setPosition(t_pos); 
		this->pickupSound.setVolume(33);}
	
	virtual void draw(sf::RenderWindow& t_window);
	virtual void pickup(Player t_player);
	sf::Vector2f getPosition();
	bool active = true;
	sf::Sound pickupSound;
	sf::Sprite consumableSprite;
}



Class Instructions{
	void init();
	void draw(sf::RenderWindow&);
	void update();
	void loadContent();
}



Class RecourceHolder{
    resourceHolder();
    sf::Texture& getAttackTexture();
    sf::Texture& getMoveTexture();
    sf::Texture& getIdleTexture();
    sf::SoundBuffer& getZombieSound();
    sf::SoundBuffer zombieSoundBuffer;
    sf::SoundBuffer zombieBreathingSound;
    sf::SoundBuffer& getZombieBreathingSound();
    void loadZombieSound();
    void loadZombieTexture();


    sf::Font zombieFont;
}


Class Player{
Player(){playerAudio.loadAudio();}
	PlayerDrawables playerDrawables;
	const int MAXLIVES = 10;
	int currentLives = 10;
	int selectedSkin = 1;
	Bullet bullet[30];
	sf::RectangleShape	collisionBox;
	bool shooting = false;
	sf::CircleShape detectRadius;
	bool canMove = true;
	const int MAXAMMOPERMAG = 30;


	void pickupAmmo(int t_amount);
	void drawUI(sf::RenderWindow& t_window);
	sf::Sprite& getSprite();
	sf::Vector2f getPosition();
	void takeDamage();
	void heal();
	void animate();
	void updateText();
	void setSkin(int t_value);
	void setPosition(sf::Vector2f t_newPos);
	void updateUI(sf::View t_view);
	void initialise();
	void draw(sf::RenderWindow& t_window);
	void processInput();
	void processSprintInput();
	void processNormalMove();
	void processFireInput();
	void update(sf::RenderWindow& t_window);
	void reload();
	void refillAmmo();
	void processDetectionRadius();



}



Class Zombie{

        sf::Clock bfsTimer;
	void init(resourceHolder& t_resources);
	void draw(sf::RenderWindow& t_window);
	void update(sf::Vector2f t_playerPos,
        int t_detectionRadius, sf::RectangleShape t_playerCollisionBox,
        int& t_playerHealth, Grid& t_grid, int t_cellPlayerIsIn);
	void animate();
	std::vector<int> breadthFirst(Grid t_grid, int& t_startCellId, int& t_destCellId);
	void setPosition(sf::Vector2f t_pos);
	sf::Vector2f getPosition();
	std::vector<int> m_path;
	bool goalReached = false;
	sf::Clock audioTimer;
	sf::Clock idleTimer;
	sf::Clock firingCooldown;
	void stopProjectile();
	void getCell(Grid& t_grid);
	Cell* cellZombieIsin;
	sf::Text zombieText;
	bool finishedAttacking = true;
	enum class State { searchAlgorithm, following, attacking };
	State currentState = State::searchAlgorithm;
	bool alive = true;
	float areaOrig;
	float area1;
	float area2;
	float area3;
	Bullet zombieProjectile;
	sf::Sound zombieAttackSound;
	sf::Sound zombieBreathingSound;
	void turnToPlayer(sf::Vector2f t_playerPos);
	void processFollowPlayer(sf::Vector2f t_playerPos);
	void processIdle(sf::Vector2f t_playerPos);
	int aggroTime = 0;
	int aggroMaxTime = 360;
	float speed = 1.25f;
	int attackFrameCountDown = 0;
	const int ATTACKANIMATESPEED = 3;
	sf::RectangleShape collisionBox;
	int currentMoveFrame = 0;
	int currentAttackFrame = 0;
	int animateSpeed = 4;
	int frameCountDown = 0;
	const int AMOUNTTEXTURES = 16;
	const int AMOUNTATTACKTEXTURES = 9;
	sf::Texture zombieIdleTexture;
	sf::Sprite zombieSprite;
	sf::Texture zombieAttackTexture;
	sf::Texture zombieMoveTexture;
	sf::Vector2f velocity{ };
	int AMOUNTFRAMES = 19;
	sf::Vector2f zombieNextMovePosition;
	sf::Vector2f randomGoalPosition;


}



Class Grid{
	Cell& at(int t_index);
	Grid();
	void setupGrid(std::vector<Wall*>& t_globalWalls);
	void showNeighbours();
	sf::Font idFont;
	Cell cellGrid[10][10];
	void draw(sf::RenderWindow& m_window);
	void reset();
	int getCellPlayerIsIn(sf::Vector2f t_playerPos);
	int cellsThatShouldBePassable[12];
}



Class MainMenu{
	void anim();
	void initialise(sf::Font&);
	void draw(sf::RenderWindow&);
	void update(sf::Window&, int& t_gameMode);
}
@enduml
